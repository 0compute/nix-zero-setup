{ nix-attest, nix2container }:
let
  mkSeed =
    {
      pkgs,
      self,
      selfFilter ? (_drv: true),
      # name from flake default package
      name ? "${
        self.packages.${pkgs.stdenv.hostPlatform.system}.default.pname or "nodefault"
      }-seed",
      nix ? pkgs.nixVersions.latest,
      nixConf ? "",
      # these are tiny and make debug much easier - override to empty if desired
      debugTools ? with pkgs; [ busybox ],
      # XXX: hook in seedCfg
      githubRunner ? true,
      ...
    }@args:
    let

      inherit (pkgs)
        lib
        stdenv
        busybox
        cacert
        glibc
        nodejs
        ;
      inherit (stdenv.hostPlatform) system;

      config = lib.recursiveUpdate {
        Entrypoint = [
          # (lib.getExe (
          #   pkgs.writeShellApplication {
          #     name = "entrypoint";
          #     text = ''
          #       # mkdir -p /tmp/upper /tmp/work /mnt/merged
          #       # mount -t overlay overlay \
          #       #   -o lowerdir=/nix/store,upperdir=/tmp/upper,workdir=/tmp/work \
          #       #   /mnt/merged
          #       # mount --bind /mnt/merged /nix/store
          #       exec ${stdenv.shell} "$@"
          #     '';
          #   }
          # ))
          (lib.getExe' busybox "sh")
        ];
        Env = lib.mapAttrsToList (name: value: "${name}=${value}") {
          NIX_CONFIG = ''
            experimental-features = nix-command flakes

            # XXX: why?
            build-users-group =
            sandbox = false

            post-build-hook = ${
              lib.getExe (
                pkgs.writeShellApplication {
                  name = "attest-and-sign";
                  text = ''
                    set -euo pipefail

                    ${lib.getExe nix-attest.nix-attest-post-build-hook}

                    # Nix daemon passes these variables:
                    # $OUT_PATHS: Space-separated list of build outputs
                    # $DRV_PATH: The .drv file that produced them

                    # Path to your private key (Ensure the nix-daemon user can read this)
                    SIGNING_KEY="/etc/nix/cosign.key"
                    export COSIGN_PASSWORD_FILE="/etc/nix/cosign.password" # Optional: for non-interactive

                    for out_path in $OUT_PATHS; do
                        # 1. Locate the predicate generated by nix-attest
                        # Assuming nix-attest naming convention: /tmp/nix-attest/<hash>.json
                        PREDICATE_DIR="/var/lib/nix-attest"
                        PREDICATE_FILE="$PREDICATE_DIR/$(basename "$out_path").json"

                        if [[ -f "$PREDICATE_FILE" ]]; then
                            echo "Found attestation for $out_path, signing..."

                            # 2. Use cosign to attest the store path
                            # We use --replace to overwrite if a signature already exists for this path
                            cosign attest --key "$SIGNING_KEY" \
                                --predicate "$PREDICATE_FILE" \
                                --type slsaprovenance \
                                --yes \
                                "file://$out_path"
                        else
                            # Fallback: Just sign the blob if no predicate exists
                            echo "No predicate found for $out_path, signing as raw blob..."
                            cosign sign-blob --key "$SIGNING_KEY" \
                                --bundle "$out_path.sigstore.json" \
                                --yes \
                                "$out_path"
                        fi
                    done
                  '';
                }
              )
            }

            # no sub, no fallback, build can only happen here
            substitutes = false
            fallback = false

            ${nixConf}
          '';
          LD_LIBRARY_PATH =
            "/lib:/lib64:/lib/" + stdenv.hostPlatform.linuxArch + "-linux-gnu";
          SSL_CERT_FILE = "${cacert}/etc/ssl/certs/ca-bundle.crt";
          PATH = "${./bin}:/bin:/usr/bin:/sbin:/usr/sbin";
        };
      } args.config or { };

      corePkgs = [
        # nix from args
        nix
      ]
      ++ [
        # nix fetchers
        cacert
      ]
      ++ debugTools;

      contents =
        # GHA runner hacks
        lib.optionals githubRunner [
          stdenv.cc.cc.lib
          glibc
          nodejs
          (pkgs.runCommand "setup" { } ''
            mkdir $out
            cd $out

            # actions runtime expects glibc libs at the multiarch path
            multiarchDir=lib/${stdenv.hostPlatform.linuxArch}-linux-gnu
            mkdir -p $multiarchDir
            ln -s ${glibc}/lib/libc.so.6 $multiarchDir
            ln -s ${stdenv.cc.cc.lib}/lib/libstdc++.so.6 $multiarchDir

            externals=__e
            mkdir $externals
            ln -s ${nodejs} $externals/node${lib.versions.major nodejs.version}
          '')
        ]
        ++ corePkgs
        ++ (lib.concatMap
          (
            drv:
            lib.concatMap (attr: drv.${attr} or [ ]) [
              "buildInputs"
              "nativeBuildInputs"
              "propagatedBuildInputs"
              "propagatedNativeBuildInputs"
            ]
          )
          (
            let
              getDerivations =
                attr: lib.filter selfFilter (lib.attrValues (self.${attr}.${system} or { }));
            in
            # apps have { type = "app"; program = "..."; }.
            lib.filter (drv: lib.isDerivation drv && selfFilter drv) (
              map (app: app.package or null) (lib.attrValues (self.apps.${system} or { }))
            )
            ++ getDerivations "checks"
            ++ getDerivations "packages"
          )
        )
        ++ args.contents or [ ];

      image = nix2container.packages.${system}.nix2container.buildImage (
        (lib.removeAttrs args (
          (builtins.attrNames (builtins.functionArgs mkSeed))
          ++ [
            "config"
            "contents"
          ]
        ))
        // {
          inherit config name;
          copyToRoot = [
            (pkgs.buildEnv {
              name = "root";
              paths = contents;
              pathsToLink = [
                "/bin"
                "/lib"
              ]
              ++ lib.optionals githubRunner [ "/__e" ];
            })
          ];
          maxLayers = 100;
          initializeNixDatabase = true;
        }
      );
    in
    # expose metadata for unit testing and inspection. buildLayeredImage does not
    # support passthru or automatically export its internal arguments
    image // { inherit contents config corePkgs; };
in
mkSeed
